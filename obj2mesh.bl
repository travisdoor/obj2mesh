//************************************************************************************************
// obj2mesh
//
// File:   obj2mesh.bl
// Author: Martin Dorazil
// Date:   21/11/19
//
// Copyright 2019 Martin Dorazil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//************************************************************************************************

#load "experimental/array.bl"
#load "std/memory.bl"
#load "std/print.bl"
#load "std/file.bl"
#load "std/debug.bl"
#load "std/utils.bl"

MESH_COLOR_FLAG : u32 : 1;
MESH_VERT_FLAG  : u32 : 2;
MESH_NORM_FLAG  : u32 : 4;
MESH_UV_FLAG    : u32 : 8;

MeshHeader :: struct {
    vc: u32;
    ic: u32;
    flags: u32;
}

TEST_IN_FILE :: "test.obj";
TEST_OUT_FILE :: "test.mesh";
TEST_VERT_COUNT : u32 : 10;

color : *Array = null; 
vert : *Array = null; 
norm: *Array = null; 
uv : *Array = null; 
indices : *Array = null; 
tmp_color : *Array = null; 
tmp_vert : *Array = null; 
tmp_norm: *Array = null; 
tmp_uv : *Array = null; 

current_line := 0;

main :: fn () s32 {
    in_file :: TEST_IN_FILE;
    out_file :: TEST_OUT_FILE;

    tmp_color = array_new(v4);
    tmp_vert = array_new(v3);
    tmp_norm = array_new(v3);
    tmp_uv = array_new(v2);
    defer array_delete(tmp_color);
    defer array_delete(tmp_vert);
    defer array_delete(tmp_norm);
    defer array_delete(tmp_uv);

    color = array_new(v4);
    vert = array_new(v3);
    norm = array_new(v3);
    uv = array_new(v2);
    indices = array_new(u32);
    defer array_delete(color);
    defer array_delete(vert);
    defer array_delete(norm);
    defer array_delete(uv);
    defer array_delete(indices);

    print("Converting '%'.\n", in_file);
    if !load_obj(in_file) {
        print_err("There were errors during processing file '%'.\n", in_file);
        return 1;
    }

    buffer_size :: sizeof(MeshHeader) +
        (cast(usize) color.len) * sizeof(v4) +
        (cast(usize) vert.len) * sizeof(v3) +
        (cast(usize) norm.len) * sizeof(v3) +
        (cast(usize) uv.len) * sizeof(v2) +
        (cast(usize) indices.len) * sizeof(u32);

    buffer := mem_alloc(buffer_size); 
    defer mem_free(buffer);

    header := cast(*MeshHeader) buffer;
    header.vc = auto vert.len;
    header.ic = auto indices.len;
    header.flags = 0;
    if color.len > 0 { header.flags = header.flags | MESH_COLOR_FLAG; }
    if vert.len > 0 { header.flags = header.flags | MESH_VERT_FLAG; }
    if norm.len > 0 { header.flags = header.flags | MESH_NORM_FLAG; }
    if uv.len > 0 { header.flags = header.flags | MESH_UV_FLAG; }

    // build content
    ptr := ptr_shift_bytes(buffer, sizeof(MeshHeader));

    if is_flag_u32(header.flags, MESH_COLOR_FLAG) {
        size_bytes :: (cast(usize) color.len) * sizeof(v4);
        mem_copy(ptr, color.ptr, size_bytes);
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    if is_flag_u32(header.flags, MESH_VERT_FLAG) {
        size_bytes :: (cast(usize) vert.len) * sizeof(v3);
        mem_copy(ptr, vert.ptr, size_bytes);
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    if is_flag_u32(header.flags, MESH_NORM_FLAG) {
        size_bytes :: (cast(usize) norm.len) * sizeof(v3);
        mem_copy(ptr, norm.ptr, size_bytes);
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    if is_flag_u32(header.flags, MESH_UV_FLAG) {
        size_bytes :: (cast(usize) uv.len) * sizeof(v2);
        mem_copy(ptr, uv.ptr, size_bytes);
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    {
        if indices.len <= 0 { panic("Invalid indices!"); }
        size_bytes :: (cast(usize) indices.len) * sizeof(u32);
        mem_copy(ptr, indices.ptr, size_bytes);
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    // write to the file
    file :: file_open(out_file, FileOpenModes.Write, FileOpenModes.Binary);
    //defer file_close(file);

    w :: file_write_binary(file, auto buffer, buffer_size);
    print("Written % kB to '%'.\n", (cast(f32) w) / 1024.f, out_file);
    file_close(file);

    test_load(out_file);

    return 0;
}

load_obj :: fn (filename: string) bool {
    // cleanup buffers
    current_line = 0;
    array_clear(color);
    array_clear(vert);
    array_clear(norm);
    array_clear(uv);
    array_clear(tmp_color);
    array_clear(tmp_vert);
    array_clear(tmp_norm);
    array_clear(tmp_uv);

    file :: file_open(filename, FileOpenModes.Read);
    defer file_close(file);

    if file == null {
        print_err("File '%' not found!", filename);
        return false;
    }

    i := 0;
    s :: file_read_all(file);
    defer string_delete(s);

    dup := s;
    
    loop dup.len > 0 {
        current_line += 1;
        if string_compare_n(dup, "mtllib", 6) {
            // material lib
            consume_n(&dup, 6);

        } else if string_compare_n(dup, "vn", 2) {
            // normal
            consume_n(&dup, 2);
            consume_spaces(&dup);

            array_push(tmp_norm, consume_v3(&dup));
            
        } else if string_compare_n(dup, "vt", 2) {
            // UV 
            consume_n(&dup, 2);
            consume_spaces(&dup);

            array_push(tmp_uv, consume_v2(&dup));

        } else if string_compare_n(dup, "f", 1) {
            // face
            consume_n(&dup, 1);
            consume_spaces(&dup);
            if !consume_face(&dup) {
                return false;
            }

        } else if string_compare_n(dup, "v", 1) {
            // vertex
            consume_n(&dup, 1);
            consume_spaces(&dup);

            array_push(tmp_vert, consume_v3(&dup));
        }

        // eat rest of the line
        consume_line(&dup);
    }

    print("vc: %, nc: %, uvc: %; i: %\n", vert.len, norm.len, uv.len, indices.len);
    return true;
}

consume_line :: fn (s: *string) {
    loop s.len > 0 {
        c :: consume_char(s);
        if c == '\n' { break; }
    }
}

consume_spaces :: fn (s: *string) {
    loop s.len > 0 {
        c :: (^s)[0];
        if c != ' ' { break; }
        consume_char(s);
    }
}

consume_char :: fn (s: *string) u8 #inline {
    c :: (^s)[0];
    if s.len > 1 { s.ptr = &(^s)[1]; }
    s.len -= 1;

    return c;
}

consume_n :: fn (s: *string, n: s32) #inline {
    loop i := 0; s.len > 0 && i < n; i += 1 {
        consume_char(s);
    }
}

consume_face :: fn (s: *string) bool {
    group := 0; // 0 - vertex, 1 - UV, 2 - normal
    index : u32 = 0;
    loop s.len > 0 {
        c :: (^s)[0];
        if c == '\n' { break; }
        if c == ' ' { break; }
        if c == '/' {
            consume_char(s);
            continue;
        }

        i := consume_u32(s);
        if i == 0 {
            print_err("%: Invalid face member id.", current_line);
            return false;
        }

        // We need this as array index later.
        i -= 1;
        
        if group == 0 {
            // vertex
            if i >= auto tmp_vert.len {
                print_err("%: Vertex face id out of range!", current_line);
                return false;
            }

            v :: cast(*v3) array_at(tmp_vert, auto i);
            if v == null { panic(); }
            
            index = auto vert.len;
            array_push(vert, ^v);
        } else if group == 1 {
            // UV
            if i >= auto tmp_uv.len {
                print_err("%: UV face id out of range!", current_line);
                return false;
            }

            v :: cast(*v2) array_at(tmp_uv, auto i);
            if v == null { panic(); }
            
            index = auto uv.len;
            array_push(uv, ^v);
        } else if group == 2 {
            // normal
            if i >= auto tmp_norm.len {
                print_err("%: Normal face id out of range!", current_line);
                return false;
            }

            v :: cast(*v3) array_at(tmp_norm, auto i);
            if v == null { panic(); }
            
            index = auto norm.len;
            array_push(norm, ^v);
        } else {
            print_err("%: Unexpected face group member!", current_line);
            return false;
        }
        
        group += 1;
    }

    array_push(indices, index);

    sum :: vert.len + norm.len + uv.len + indices.len; 
    if sum % vert.len != 0 {
        print_err("%: Triangle data malformed!", current_line);
        return false;
    }

    return true;
}

consume_v3 :: fn (s: *string) v3 {
    v := {:v3: 0};
    
    v.x = consume_f32(s);
    consume_spaces(s);
    v.y = consume_f32(s);
    consume_spaces(s);
    v.z = consume_f32(s);
    
    return v;
}

consume_v2 :: fn (s: *string) v2 {
    v := {:v2: 0};
    
    v.x = consume_f32(s);
    consume_spaces(s);
    v.y = consume_f32(s);
    
    return v;
}

consume_f32 :: fn (s: *string) f32 {
    n := 0;
    e := 1;
    is_negative := false;
    is_after_comma := false;

    loop s.len > 0 {
        c :: (^s)[0];
        if c == '-' {
            is_negative = true;
        } else if c == '.' {
            is_after_comma = true;
        } else if c >= '0' && c <= '9' {
            n = n * 10 + (auto c - '0');
            if is_after_comma {
                e *= 10;
            }
        } else {
            break;
        }

        consume_char(s);
    }

    v := cast(f32) n / cast(f32) e; 
    if is_negative { v = -v; } 
    return v;
}

consume_u32 :: fn (s: *string) u32 {
    n : u32 = 0;
    loop s.len > 0 {
        c :: (^s)[0];
        if c >= '0' && c <= '9' {
            n = n * 10 + (auto c - '0');
        } else {
            break;
        }

        consume_char(s);
    }

    return n;
}

test_load :: fn (filename: string) {
    Mesh :: struct {
        c: []v4;
        v: []v3;
        n: []v3;
        uv: []v2;
        indices: []u32;
    };

    print("\n--- TEST LOAD BEGIN ---\n");
    file :: file_open(filename, FileOpenModes.Read, FileOpenModes.Binary);
    defer file_close(file);

    size :: file_get_size_bytes(file);
    if size == 0 {
        print_warn("Invalid file size of '%'!", filename);
        return;
    }

    buffer :: mem_alloc(size);
    defer mem_free(buffer);
                   
    r :: file_read_all_binary(file, buffer, size);
    print("Loaded % bytes from '%'.\n", r, filename);

    mesh := {:Mesh: 0};
    header :: cast(*MeshHeader) buffer;
    print("%\n", ^header);

    ptr := ptr_shift_bytes(buffer, sizeof(MeshHeader));

    if is_flag_u32(header.flags, MESH_COLOR_FLAG) {
        print_log("A");
        size_bytes :: header.vc * sizeof(v4);
        mem_copy(auto mesh.c.ptr, ptr, size_bytes);
        ptr = ptr_shift_bytes(ptr, size_bytes);
        mesh.c.len = auto header.vc;
    }

    if is_flag_u32(header.flags, MESH_VERT_FLAG) {
        size_bytes :: header.vc * sizeof(v3);
        mesh.v.ptr = auto ptr;
        mesh.v.len = auto header.vc;
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    if is_flag_u32(header.flags, MESH_NORM_FLAG) {
        size_bytes :: header.vc * sizeof(v3);
        mesh.n.ptr = auto ptr;
        mesh.n.len = auto header.vc;
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    if is_flag_u32(header.flags, MESH_UV_FLAG) {
        size_bytes :: header.vc * sizeof(v2);
        mesh.uv.ptr = auto ptr;
        mesh.uv.len = auto header.vc;
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }

    {
        size_bytes :: header.vc * sizeof(u32);
        mesh.indices.ptr = auto ptr;
        mesh.indices.len = auto header.vc;
        ptr = ptr_shift_bytes(ptr, size_bytes);
    }



    print("--- TEST LOAD END ---\n\n");
}
